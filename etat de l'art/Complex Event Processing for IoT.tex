%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
\documentclass[11pt]{article}
\input{structure.tex}
\bibliography{biblio}
\begin{document}
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------
\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	\center
	%------------------------------------------------
	%	Headings
	%------------------------------------------------
	\textsc{\LARGE University of Namur}\\[1.5cm]
	\textsc{\Large Introduction to the scientific process}\\[0.5cm]
	\textsc{\large IHDCB339}\\[0.5cm]
	%------------------------------------------------
	%	Title
	%------------------------------------------------	
	\HRule\\[0.4cm]
	{\huge\bfseries State of the Art: Complex Event Processing for Internet of Things}\\[0.4cm]
	\HRule\\[1.5cm]	
	%------------------------------------------------
	%	Author(s)
	%------------------------------------------------	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			\large
			\textit{Author}\\
			Kenny \textsc{Warszawski} 
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Supervisors}\\
			Moussa \textsc{Amrani}
			\\
			Pierre-Yves \textsc{Schobbens} 
		\end{flushright}
	\end{minipage}	
	%------------------------------------------------
	%	Date
	%------------------------------------------------	
	\vfill\vfill\vfill
	{\large\today}
	%------------------------------------------------
	%	Logo
	%------------------------------------------------
	\vfill\vfill
	\includegraphics[width=0.2\textwidth]{placeholder.png}\\[1cm]
	\vfill
\end{titlepage}

%----------------------------------------------------------------------------------------
%	Beginning
%----------------------------------------------------------------------------------------

\section{Introduction}

The Internet of Things is omnipresent and the amount of connected devices is increasing day by day. The Internet of Things is different from a classic information system by its capability for integrating with the physical world. Those devices are used in plenty of sectors (health, industry, transport, home automation, \ldots) and their users can be both professionals and individuals. Nowadays, we can see the apparition of connected devices for home to facilitate our daily life. (e.g: Google Home, Nest, Philips Hue) Internet of Things is also an interesting technology for Smart Cities use case. We can imagine a city where traffic lights are optimised with the city mobility to avoid traffic jams for example. However, an important problem arises in this type of architecture. How is it possible to handle such an important data traffic efficiently ? Indeed, if an entire city has a huge amount of connected objects, the data flow to be processed is massive. Therefore efficient data processing mechanisms need to be put in place to handle such flows.
\newline
\newline
The Complex Event Processing is a part of the solution to handle such massive data flow. Another problematic is the capacity for such systems to be simple to extend. If a new connected device is joining an Internet of Things solution, this one should be easy configurable and simple to add in the business process. Evidently, it would be really expensive that each time a new device is added to the system, the software has to be updated and modifications in the source code has to be done. A viable IoT solution cannot be designed like this. 
\newline
\newline
This state of the start is organised as follows. The section \ref{context} is dedicated at putting in place the background of this state of the art. A generic overview of the Internet of Things architecture is explained roughly to underline the computation parts. The section \ref{cep} explains the basics of the Complex Event Processing in general. In parallel, examples coming from the internet of things is highlighting the concepts. The section \ref{computing-levels} is focusing on the computing layers in the Internet of Things. This aforementioned section shows the advantages and inconvenience of putting the processing part at the edge, fog or cloud layer. The section \ref{pub-sub} explains the publish-subscribe architecture based on the article \cite{A-Semantic-Publish-Subscribe-Architecture}. The section \ref{domain-applications} is regrouping different domain of applications where the Internet of Things is present. Based on the literature, the section is showing different IoT architectures where the Complex Event Processing is used for different use-cases and at which level this computing technology is useful. The state of the art is ending by a conclusion in the section \ref{conclusions} and by the problematisation part on the section \ref{problematic}. At the very end of this article, a section dedicated to the Research methodology is available in the section \ref{research-methodology}.

\newpage

\section{Context} \label{context}

\subsection{Internet of Things}

The Internet of Things(IoT) is a novel paradigm that is rapidly gaining ground in the scenario of modern wireless telecommunications. The basic idea of this concept is the pervasive presence around us of a variety of things or objects – such as Radio-Frequency IDentification (RFID) tags, sensors, actuators, mobile phones, etc. – which,through unique addressing schemes, are able to interact with each other and cooperate with their neighbors to reach common goals. \cite{2}
\newline
\newline
The phrase "Internet of Things" was mentioned the first time by Kevin Ashton, the co-founder of the Auto-ID Center at MIT, as the title of one of his presentation. For him, today computers and the internet more generally is dependent from human intervention. The information technology architecture are all designed around the hardware, software interactions, etc but an important thing is generally set aside: people. People have a limited time, attention and accuracy. Hence they are making mistakes about the real world. Thus, the data generated by humans isn't the exact representation of the reality in an Information System.
\newline
\newline
A thing can be any connected device from our daily life that is able to capture information from the physical world by sensors and send it through a network. This information can be kept by another layer able to process the data and make it meaningful by an application. 

\subsection{IoT architecture}

The architecture of an Internet of Things solution can be implemented with various technologies and in very different infrastructures. However, a generic high level architecture is common to all IoT projects:
\begin{figure}[H]
	\includegraphics[width=\textwidth,height=200pt]{assets/Abstract_IoT_Architecture.png} 
	\caption[Generic Architecture]{Generic Architecture. (Source: \cite{Future-Internet-The-Internet-of-Things})}
	\label{fig:genericArchitecture}
\end{figure}

\textbf{Perception Layer:} The perception layer or device layer is the layer where physical objects will be able to capture data via sensors. These sensors are able to collect real world data. These data can be or not be processed upstream to add meta-data by the connected object itself and will be forwarded to the Network Layer.

\textbf{Network Layer:} The Network Layer or Transmission Layer. This layer transfers the informations from to Perception Layer to the Middleware Layer. This transfer can be accomplished by different communication technologies like Wifi, 3g, Bluetooth, etc.

\textbf{Middleware Layer:} The Middleware Layer is the common layer for all physical objects of an IoT architecture. The middleware is responsible to take automatic decisions based on informations coming for the devices and store the results in a database. 

\textbf{Application and Business Layer}: The Application Layer is where smart applications are running to produce complex processes. These applications will consume data from connected objects previously processed by the middleware to act effectively on a specific situation. These application can transmit actions to execute on a particular type of service. The Business Layer is important for the global management of the system. This one is rather a layer of global monitoring which produces graphs and statistics at the business level.

\subsection{Data Flow}

The previous architecture can be simplified to highlight the layer of architecture on which this state of the art will focus.
\newline
\begin{figure}[h]
	\includegraphics[width=\textwidth,height=180pt]{assets/Basic_IOT_Architecture.png} 
	\caption[Simple IoT Architecture]{Simple IoT Architecture. (Source: \cite{Future-Internet-The-Internet-of-Things})}
	\label{fig:simpleArchitecture}
\end{figure}

This state of the art is focusing on the "Computation and Processing System" layer because at that stage, the data processing is the most critical and the data flow is the highest. Obviously, the Communication Layer must be robust enough to transmit the data efficiently but this topic will not be tackled in this article.

%----------------------------------------------------------------------------------------
%	Complex Event Processing
%----------------------------------------------------------------------------------------

\section{Complex Event Processing} \label{cep}

\subsection{Definition}

Complex Event Processing (CEP) is a set of methods and techniques for tracking
and analysing real-time streams of informations and detecting patterns or correlations
of unrelated data (complex events) that are of interest to a particular
business. \cite{1} The complex event processing is the engine of real-time applications that needs to have real-time informations from an environment to respond as fast as possible. A standard Request/Reply with synchronous processes cannot correlate different type of events and respond in a timely manner. Complex Event Processing mechanisms are often used in Event Driven architectures. This architecture fits with the Internet of Things needs. This kind of architecture is driven by events sent by connected objects. Then, the services at the application layer are consuming those events.

\subsection{Event Correlation}

The events coming directly from the Thing's sensors are call raw events. Those events are the trigger of one or multiple process in an IoT solution. The raw events are the events coming from the real world. It may represent a simple real-world event or a complex real-world event. Those raw events often need to be pre-processed before integrating a more sophisticated system. Without the pre-processing it would be difficult for a system to understand the information correctly and correlate it with other events. A strict semantic between different type of events have to be put in place for the whole IoT system. That's why a complete ontology should structure all the domain application. Generally, two types of events can occur in the system: Internal and External. The internal events are the events sent by the application layer. The external event are the events sent by the "physical" sensors.

\subsection{CEP Engine} \label{cep-engine}

The CEP engine is consuming the events sent by the physical objects on the Communication Layer. This engine can define a bunch of rules where each event received will be evaluated. A rule represents a complex condition that can be based on multiple events and on a time window. For example, if all connected cameras in a house are sending that there aren't any move in the house in a time window of 60 seconds, an event saying that nobody is in the house will be sent. Then, some specific actions can be taken by connected devices in the house. Basically, a Complex Event Processing Engine correlates multiple type of events based on the time. Then, if the pattern defined in the rule is matching with the ingested events, a complex event is sent. A complex event is an event that summarizes, represents, or denotes a set of other events\cite{glossary}. The complex events generated can themselves triggers another CEP rule or an application process.
\newline
\begin{figure}[h]
	\includegraphics[width=\textwidth,height=160pt]{assets/cep-pattern-decision-reaction.png} 
	\caption[CEP Pattern Decision Reaction]{CEP Pattern Decision Reaction. (Source: https://www.tibco.com/blog/2009/12/18/cep-more-than-event-patterns)}
	\label{fig:cep-pattern-decision-reaction}
\end{figure}

The rules are able to correlate different type of events only if their structure are known. If an event is unrecognisable by the pattern, this event can be ignored or a different kind of action can be put in place. It is possible to send a warning event that something unexpected by the system happened for example. 
\newline
\newline
The technologies implementing CEP concepts are querying Time Series Databases where each event received are stored. Thoses databases are optimised for queries based on a time window. In a lot of CEP framework like Apache Flink, those CEP pattern matching rules are describe seemly an SQL Query and uses Event Pattern Languages. 

\subsection{Event Pattern Languages}

An Event Pattern Language (EPL) is a language used by CEP engines in order to describe the relations between events that match a specific pattern. The syntax of EPL's are quite similar to SQL queries. The Example 1 is retrieving dates where the temperature was bigger than 30 degrees Celsius.
\newline
\newline
\underline{\textbf{Example 1:}}
\begin{verbatim}
	SELECT Thermometer.date
	FROM DataSource
	WHERE temperature > 30
\end{verbatim}
A plenty of primitive operators exists in Event Pattern Languages to describe the rule's behaviour. The following operators are coming from ThingML framework but are available in most of CEP frameworks:
\newline
\newline
\textbf{Selection:} Filters relevant events based on the values of their attributes.\cite{6} For example, we can select all Air Pressure events between 101300 Pa and 101400 Pa.
\newline
\textbf{Projection:} Extracts or transforms a subset of attributes of the events.\cite{6}
\newline
\textbf{Window:} Defines which portions of the input events to be considered for detecting pattern.\cite{6} For example, a rule can concern the last 30 seconds events.
\newline
\textbf{Conjunction:} Consider the occurrences of two or more events.\cite{6} This operator is basically a logical 'AND' operator.
\newline
\textbf{Disjunction:} Consider the occurrences of either one ore more events in a predefined set.\cite{6} This operator is basically a logical 'OR' operator.
\newline
\textbf{Sequence:} Introduces ordering relations among events of a pattern which is satisfied when all the events have been detected in the specified order.\cite{6}
\newline
\textbf{Repetition:} Considers a number of occurrences of a particular event.\cite{6}
\newline
\textbf{Aggregation:} Introduces constraints involving some aggregated attribute values.\cite{6} For example, the average temperature of all Weather events is an aggregation.
\newline
\textbf{Negation:} Prescribes the absence of certain events.\cite{6} This operator is basically a logical 'NOT' operator.

%--------------------------------------------------------------------------------------

\subsection{Event-Condition-Action Pattern}

As seen in section \ref{cep-engine}, the CEP Engine is composed of events to detect, a set of rules to execute and actions to perform. Basically, this CEP approach is called Event-Condition-Action and separate the operations in three stages : Event processing, Condition evaluation and Action execution. This pattern is often used in the most popular CEP Frameworks (e.g.Apache Flink, Esper, Google Dataflow and Apache Heron). The Event processing stage is itself divided into three parts : Event detection, Event subscription and Event processing. The aforementioned stage is responsible to detect events, subscribe and process events. The condition stage is the step where rules are defined by Event Pattern Languages. The Rule Engine is composed of a fact base and rule base. The fact base represents the current state of all facts defined in the system. A fact is a situation that can occur in the system. For example, if a detection event is sent by a sensor in a bedroom, the fact can be "Someone is in the Bob's bedroom". Rules consist of an ECA based pattern: on {<}event{>} if {<}condition{>} then {<}action{>}. Whenever an event occurs, the rule scanner checks all relevant rules to determine any consequent actions that need to be initiated. \cite{An-internet-of-things-system-architecture}

\begin{figure}[h]
	\includegraphics[width=\textwidth,height=90pt]{assets/ECA_illustration.png}
	\caption[Event-Condition-Action]{
	Event-Condition-Action. (Source: \cite{An-internet-of-things-system-architecture})
	}
	\label{fig:Event-Condition-Action}
\end{figure}

\subsection{Database and Data Stream Management Systems}

Real-time applications are consuming the data in a different way comparing to a traditional system. A traditional information system using a Database Management Systems (DBMS), the information stored in the database related to an specific entity is a "static" data persisted. The information stored in an aggregation of the reality. Only the current state of the information is relevant for the system. This type of Data management doesn't fit all real-time applications' needs. A real-time application needs to correlate each events coming into the system. An IoT solution is sending too much data into the system. It's not possible for a traditional database to store, query and respond in a timely manner. \cite{Complex-event-processing-for-the-Internet-of-Things}
\newline
\newline
The Data Stream Management Systems (DSMS) are designed to handle potentially infinite and fast changing event streams. Obviously, it is not possible to query the all history of events that came from the beginning of the solution and respond in milliseconds. Different approaches exist to limit the amount of data processed. Roughly, compression techniques exists to summarize a set of data already queried. Another technique consists of setting a time window to pick a portion of data in the time. 

%--------------------------------------------------------------------------------------

\section{Computing Levels} \label{computing-levels}

The main preoccupations of a real-time solution in IoT is to have the lowest latency between all devices. To process all data coming from sensors, CEP engines can help reducing the processing time. The CEP engines can be placed at different level of the IoT architecture. The place where Complex Event Processing is used depends of the business needs. 

%----------------------------------------------------------------------------------------

\subsection{Cloud Computing}

The Cloud Computing places the computing complexity at the cloud level. All the data coming from the sensors have to transit by the connected object, sometimes by a middleware and then it can be consumed by a CEP Engine in the cloud. The Cloud Computing is common for near real-time applications where a little bit of latency is not critical.
\newline
\begin{figure}[h]
	\includegraphics[width=\textwidth,height=160pt]{assets/Cloud_Computing.png}
	\caption[Cloud Computing]{
	Cloud Computing. (Source: https://mapr.com/blog/cool-fitness-tracker-using-iot-sensors-cloud-ml-on-mapr)}
	\label{fig:Cloud-Computing}
\end{figure}

This solution is optimal for the near real-time cloud monitoring because all events coming from the devices are sent to the cloud. Then a precise metrics history can be retrieved. Obviously all data persisted have a cost. This type of solution is extremely demanding in storage space if all the history is persisted.
\newline
\newline
Of course the Cloud Computing can be coupled with other levels of computing and it's often the case. The Cloud Computing can be placed on the top of a multi site IoT solutions where millions of data are coming from thousands of connected objects in the world. Then this solution can reflect a High Level overview of a global IoT system and available all over the world.

%----------------------------------------------------------------------------------------

\subsection{Fog Computing}

The Fog Computing places the computing intelligence at the local network level. Typically the complexity is put between the Cloud and the IoT sensors. The devices are sending their data to a Middleware and the CEP engine is processing the data locally and send the processed events to a service running in the Cloud or on a local server. This method offers the CEP performances on a closer level where the data are created. Then the applications where latency is crucial, the Fog Computing can fit with their business needs. For example, the auto mobile or aerospace sector are more and more connected and the reactivity of their system needs to be as fast as possible. Compared to a device-to-cloud architecture, placing processing closer to the devices can reduce the latency since the physical distance is shorter and potential response time in a data center can be removed. Compared to a deviceonly architecture, latency can be reduced since computationintensive tasks that take a long time on resource-constrained sensor devices can be moved to more capable fog computing nodes. The motivation can also be to keep the latency predictable.\cite{Towards-power-consumption-delay}

\begin{figure}[H]
	\includegraphics[width=\textwidth,height=160pt]{assets/Fog_Computing.jpg}
	\caption[Fog Computing]{
		Fog Computing. (Source: https://www.manuauto.com/category/moxa/page/4)
	}
	\label{fig:Fog-Computing}
\end{figure}

It can happen that the edge devices are sending too much data at very high rate. Therefore the processing engine at fog level is not treating the data fast enough because the processing of a huge amount of data is taking too much time. The Complex Event Processing can be put at the Edge devices level. The terms Fog and Edge computing have different meanings depending on the article. In some article, edge computing refers to the enabling technologies allowing computation to be performed at the edge of the network,on downstream data on behalf of cloud services and upstream data on behalf of IoT services.\cite{Edge-Computing-Vision-and-Challenges} The limit between Fog and Edge computing is not clear. In this state-of-the-art we consider the Fog to be a higher layer on the top of physical devices like a server on a private network. 

%----------------------------------------------------------------------------------------

\subsection{Edge Computing}

The Edge Computing places the computing complexity at the Physical Layer. It can be an IoT gateway where data is pre-processed before being pushed to the Cloud or whatever. For example, in e-health some sensors can be put in a human body and the informations coming from the sensors are sent to a smartphone. The smartphone is processing those information before sending them. This method reduces the network traffic to the Fog Nodes and/or the Cloud because less informations will be transferred. Therefore it reduces the risk of data congestion and the CEP engines are not flooded. Edge Computing is generally used by industries in Cyber Physical Systems\footnote{Cyber-Physical Systems (CPS) are integrations of computation and physical processes. Embedded computers and networks monitor and control the physical processes, usually with feedback loops where physical processes affect computations and vice versa \cite{5}}.

%----------------------------------------------------------------------------------------

\section{Publish-Subscribe Architecture} \label{pub-sub}

The article "A Semantic Publish-Subscribe Architecture" \cite{A-Semantic-Publish-Subscribe-Architecture} suggests an interesting asynchronous architecture based on the Publish-Subscribe design pattern. The publish-subscribe pattern in software architecture is a messaging pattern where the sender of the message doesn't know the receiver. On the other side, the receiver doesn't know the sender as well. The publisher is sending a message on a message queue where subscriber(s) are listening to. In Internet of Things solutions, the producers and consumers can be the connected objects themselves but it can also be an application layer in the Cloud for example. The connected objects are publishing events on event topics and the application layer processes those events.

\begin{figure}[H]
	\includegraphics[width=\textwidth,height=200pt]{assets/SPS_Architecture.png}
	\caption[Semantic Publish Subscribe Architecture]{
	Semantic Publish Subscribe Architecture. (Source: \cite{A-Semantic-Publish-Subscribe-Architecture})}
	\label{fig:Semantic-Publish-Subscribe-Architecture}
\end{figure}

The SPS architecture prone the modularity, extensibility and cost-effective vision. It splits the physical world from its digital representation. The primary characteristic consists of splitting clients into 3 categories: consumers, producers and aggregators. The business logic is driven by the aggregators. The producers and the consumers are the bridge between the physical world and the virtual representation of the systems. This principle keeps the business logic at the aggregator level in order to keep the clients and producers as simple as possible. It gives to the producers the unique responsibility to send data to an upper layer without executing any business logic. Hence, this system is easier to extend because only the aggregator layer is impacted if a business feature is added. Then, the consumers and producers can be shared by different applications.
\newline
\newline
The role of the producers is to collect the data from the sensors. The producer can optionally make a local processing where it encapsulate the data to a semantic format. After that, the producer send the information to the SUB Engine that will store the data in a Triplestore.
Contrarily, the consumers are listening to the concrete events coming in the SUB Engine that can be a result of a processing done by an aggregator. After receiving an notification, the consumers extract the raw data and send it to a devices through a legacy interface.
\begin{figure}[H]
	\includegraphics[width=\textwidth,height=190pt]{assets/simple_SPS_example.png}
	\caption[Sequence diagram of Smart Lightning]{
	Sequence diagram of Smart Lightning. (Source: \cite{A-Semantic-Publish-Subscribe-Architecture})}
	\label{fig:Sequence-diagram-of-Smart-Lightning}
\end{figure}
The aggregators are listening to the events sent by the producer through the SUB Engine. Each aggregator subscribes to each event type they need for their business process. The fig.\ref{fig:Sequence-diagram-of-Smart-Lightning} exposes a simple use case of Smart Lightning where each type of clients described previously is used. The presence sensor acts as a producer and store the presence state in the RDF Store. The Lamp actuator acts as a consumer and subscribe to the Lamp events. The Smart Lightning acts as an aggregator to handle incoming events and triggers a business process based on those events.
\newline
\newline
\textbf{Scenario:}
\newline
1. The Lamp Actuator is subscribing to the Lamp events and the Smart Lightning aggregator is subscribing to the Presence events.
2. The Presence sensor is Sending an Event to the SUB Engine that a presence is detected. 
3. The presence event is captured by the Smart Lighting aggregator that will send an event to switch on the lamp. 
4. The "Switch ON the lamp" event is captured by the Lamp actuator that communicate the information to the connected lamp. 
5. The presence sensors is sending that no presence is detected. 
6. The Smart Lightning schedules to send an event to switch off the light after x seconds if no presence is detected during that time laps.
7. A presence is detected, then the Smart Lightning cancels his event scheduling.
8. The presence sensors is sending that no presence is detected. 
9. The Smart Lightning schedules to send an event to switch off the light after x seconds if no presence is detected during that time laps.
10. The Smart Lightning Aggregator sends the "Switch off lamp" event.
11. The Lamp actuator is switching off the light.

\section{Domain of applications} \label{domain-applications}

\subsection{Fault Tolerance}

\section{Conclusions} \label{conclusions}

\section{Problematisation} \label{problematic}

Through this state-of-the-art, some problematic aspects in the Complex Event Processing for Internet of Things domain were found. In the literature, some important aspects for an IoT solution are rarely took in account. An Internet of Things solution is continuously growing and everything around the architecture has to be designed to scale and to ease all interactions. 

\subsection{Aspects}

\subsubsection{Scalability}

One of the main challenge in IoT is the increasing of connected objects. More connected objects means that more data is sent periodically. Therefore the load of data to process increases. The Complex Event Processing is one of the answer to this problematic. The CEP will filter, aggregate, summarize the information and send it to an application layer. Then, if we have more connected objects, more complex events will be sent to this application layer. The use-case of a connected building or hospital is a great example. An initial installation can be done in a building but after a while, the connected objects increase. Thus, the application layer could be overflowed by the number of events and accordingly the processing time may take too much time. The e-health sector needs to have a fast, robust, fault tolerant and scalable infrastructure. The scalability of an IoT architecture is really important because an IoT solution is growing at the same time as the physical world. Then, the virtual world designed in an Internet of Things solution should be adapted easily with the today world and the world of tomorrow. 
\newline
\newline
All the infrastructure of an IoT solution should be flexible. The today containerization technologies offer the possibilities to do so. Kubernetes and Docker Swarm offers the possibility to manage such type of infrastructure. These technologies enable the ability to scale up vertically in term of service instance. Each instance of a containerized service can be replicated to share the load of the data to process for example. If at a moment t, a lot of data is coming to a specific service, this one can be scaled up automatically to load-balance the incoming requests. 

\subsubsection{Reliability}

The Internet of Things needs to scale horizontally in term of hardware resources. The aforementioned containerization technologies gives the ability to create clusters. Those clusters can be formed initially by 5 hosts for example. If the resources to process the data are not sufficient, it is possible to add more servers at runtime. On a traditional client-server architecture, the client is connecting to one and exactly one server. Nowadays, a big and complex architecture cannot rely on one unique physical (or virtual) machine. The clients (connected objects) need to have the possibility to connect on a cluster of machines containing the IoT Platform. Then, even if a host is shutting down, all the application is still running normally. There is no single point of failure.

\subsubsection{Monitorability}

An Internet of Things solution can be really complex. The complexity of such system can be explained by the presence of a huge number of connected devices. At an upper layer, the business process consuming the events generated by the devices can be really hard because a lot of type of events can be implicated for one operation. Therefore, if an error occurs somewhere in this infrastructure it reveals to be really hard to find the defects. An accurate knowledge of all processes has to be known. Then, the IoT solutions need to have a very simple and well designed monitoring tools. Those monitoring tools need to cover different aspects. It has to show relevant data for the end user if something wrong happened. 

\subsubsection{Extensibility}

An IoT solution is growing in term of connected objects and in term of functionalities. A big challenge is to reduce as much as possible the line of codes to write when a new business feature is required. IoT Platforms like MainFlux \cite{Unified-IoT-Platform-Architecture} or ThingsBoard proposes rules engine based on Complex Event Processing. It is possible to define declaratively on a UI interface, rules based on the events and trigger configurable actions. \cite{Performance-Evaluation-Of-Open-Source-IoT-Platforms} The integration with third party applications for an IoT solution is really important. The world is continuously evolving and the interoperability with other products is crucial. 
\newline
\newline
Another important point of such architecture is the ease to integrate new services. A new service is an application communicating with the IoT platform and that can perform simple or complex actions. For the developers, an SDK facilitating the communication between the IoT Platform and the services is an incredible gain of time and ease the development. An SDK contributes to the ease of extensibility of an IoT platform. 

\subsubsection{Independence between Things}

The Internet of Things is continuously evolving. Therefore, connected objects cannot rely "directly" on another object. Certainly, another device can communicate directly with another but this one should be able to be modified easily. The communication between objects should be totally configurable. All connected objects are sharing a common platform and are sharing their data through this platform. The usage of such platform provides the independence between connected objects. A publish-subscribe and micro-service architecture can be implemented to provide the same philosophy at the application Layer. The micro-services share the same queuing technology but the consumers and the producers don't know each other. Then, a fully asynchronous and service independence can be imagined.

\subsection{Question}

\subsubsection{General Question}

Which Internet of Things architecture is adapted for an evolving solution where the connected objects are growing day by day ? Which technologies can respond to the previously boarded criterias and how to implement those concepts for a real world use-case ? 

\subsubsection{Sub-Question}

How to quantify objectively the criterias of scalability, reliability, monitorability, extensibility of an IoT solution ? All those points need to reflect the impact of the performances, resources, \ldots.

\begin{itemize}
	\item \textbf{Scalability:} The scalability can be split into two categories : the hardware scalability and the applications scalability. The hardware scalability can be quantified by the ability of the system to add or not a new machine to a cluster at runtime. It is possible to measure the ability of this new machine to share the processing load in term of usage of the CPU and the incoming requests. In the other hand, the application scalability can be quantified by the possibility or not to replicate a service if this one is overflowed. The load balancing between the service instances can be measured to quantify the effective gain of performances. A same system with one instance and a system with multiple can be measured in term of reactivity. 
	
	\item \textbf{Reliability:} The reliability is tightly coupled with the high availability of a system and the previous scalability point. An IoT solution should be fault tolerant and as much the hardware and the applications must me robust. This point can be quantified by the possibility of shutting down application servers, stopping services and inspect the impacts on the system. The system should be still running. In a degraded mode but all the solutions shouldn't stop brutally.

	\item \textbf{Monitorability:} The monitorability of a system is difficult to quantify. All that can be quantified is the ability to see easily what's happening across the system. Is it simple for an end-user to see what is going on on the system ? Are the metric useful for the user ? Is it configurable ? Is it possible to create new dashboards ?

	\item \textbf{Extensibility:} The extensibility of an Internet of Things solution can be measured by the presence or not of an SDK for the IoT platform used. Is it possible to integrate with third parties ? Is it possible to configure it easily for the end user and is it possible to modulate processes via User Interfaces ? 
	
\end{itemize}

\newpage

%----------------------------------------------------------------------------------------

\section{Research Methodology} \label{research-methodology}

\textbf{Main resources :}
\begin{itemize}
	\item \textbf{IEEE Xplore} 
	\item \textbf{Springer} 
\end{itemize}

The methodology used for this research was inspired by the Systematic Mapping Study. \cite{sms} Initially, the first query done on the IEEE Xplore Digital Library was : Complex Event Processing AND Internet of Things. This result gave too much results, around 200. To reduce this number, only the papers published between 2014 and 2019 were chosen. The Internet of Things is a subject that is continuously evolving, then it is more interesting to focus on the newest technologies. This filter excluded around 40 articles. After that the 100 most cited were chosen for the second step.
\newline
\newline
The second step consisted of reading all the 100 abstracts of the articles. Then, the most pertinent for the subject were selected. Only fourteen articles were selected out of the hundred. After that, a first reading of all articles revealed unnecessary articles and only few of them (6) were deeply analysed and summarized. After summarizing and a better understanding of the problematics for the subject, it was necessary to find a glossary \cite{glossary} with all technical definitions. A lot of authors are employing various words for the same concept and it was sometimes fastidious to correlate all the information together to have a good understanding of all information.  
\newline
\newline
The second search on IEEE Xplore consisted of searching other Data processing techniques in the domain of Internet of Things. The query was : ((((Internet of Things) AND Data Processing) NOT Complex Event Processing)). With the filters :  2014 to 2019 and the 100 most cited papers. For this search, the same methodology was applied.
\newline
\newline
After all this research, the writing of this state-of-the-art started. Sometimes, some informations were missing to correlate some parts with others or some concepts weren't explained clearly. Then, some small additional researches were done during the writing.

%----------------------------------------------------------------------------------------
%----------------------------------------THE END-----------------------------------------
%----------------------------------------------------------------------------------------

\newpage
\listoffigures
\nocite{*}
\printbibliography

\end{document}
