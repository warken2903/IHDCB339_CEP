%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------
\documentclass[11pt]{article}
\input{structure.tex}
\bibliography{biblio}
\begin{document}
%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------
\begin{titlepage}
	\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
	\center
	%------------------------------------------------
	%	Headings
	%------------------------------------------------
	\textsc{\LARGE University of Namur}\\[1.5cm]
	\textsc{\Large Initiation à la démarche scientifique}\\[0.5cm]
	\textsc{\large IHDCB339}\\[0.5cm]
	%------------------------------------------------
	%	Title
	%------------------------------------------------	
	\HRule\\[0.4cm]
	{\huge\bfseries State of the Art: Complex Event Processing for Internet of Things}\\[0.4cm]
	\HRule\\[1.5cm]	
	%------------------------------------------------
	%	Author(s)
	%------------------------------------------------	
	\begin{minipage}{0.4\textwidth}
		\begin{flushleft}
			\large
			\textit{Author}\\
			Kenny \textsc{Warszawski} 
		\end{flushleft}
	\end{minipage}
	~
	\begin{minipage}{0.4\textwidth}
		\begin{flushright}
			\large
			\textit{Supervisors}\\
			Moussa \textsc{Amrani}
			\\
			Pierre-Yves \textsc{Schobbens} 
		\end{flushright}
	\end{minipage}	
	%------------------------------------------------
	%	Date
	%------------------------------------------------	
	\vfill\vfill\vfill
	{\large\today}
	%------------------------------------------------
	%	Logo
	%------------------------------------------------
	\vfill\vfill
	\includegraphics[width=0.2\textwidth]{placeholder.png}\\[1cm]
	\vfill
\end{titlepage}

%----------------------------------------------------------------------------------------
%	Beginning
%----------------------------------------------------------------------------------------

\section{Introduction}

The Internet of Things is omnipresent and the amount of connected devices is increasing day by day.
The Internet of Things is different from a classic information system by its capability for integrating with the physical world.
Those devices are used in plenty of sectors (health, industry, transport, home automation, \ldots) and their users can be both professionals and individuals.
Nowadays, we can see the apparition of connected devices for home to facilitate our daily life. (e.g: Google Home, Nest, Philips Hue)
IoT is also an interesting technology for Smart Cities use case.
We can imagine a city where traffic lights are optimised with the city mobility to avoid traffic jams for example.
However, an important problem arises in this type of architecture.
How is it possible to handle such an important data traffic efficiently ?
Indeed, if an entire city has a huge amount of connected objects, the data flow to be processed is massive.
Therefore efficient data processing mechanisms need to be put in place to handle such flows.


\textcolor{red}{Parler des CPS, Fraud Detection, Health, Fault Tolerance, structure de l'état de l'art, etc}
\newpage

\section{Context}

\subsection{Internet of Things}

The Internet of Things(IoT) is a novel paradigm that is rapidly gaining ground in the scenario of modern wireless telecommunications. The basic idea of this concept is the pervasive presence around us of a variety of things or objects – such as Radio-Frequency IDentification (RFID) tags, sensors, actuators, mobile phones, etc. – which,through unique addressing schemes, are able to interact with each other and cooperate with their neighbors to reach common goals. \cite{2}
\newline
\newline
The phrase "Internet of Things" was mentioned the first time by Kevin Ashton, the co-founder of the Auto-ID Center at MIT, as the title of one of his presentation. For him, today computers and the internet more generally is dependent from human intervention. The information technology architecture are all designed around the hardware, software interactions, etc but an important thing is generally set aside: people. People have a limited time, attention and accuracy. Hence they are making mistakes about the real world. Thus, the data generated by humans isn't the exact representation of the reality in an Information System.
\newline
\newline
A thing can be any connected device from our daily life that is able to capture information from the physical world by sensors and send it through a network. This information can be kept by another layer able to process the data and make it meaningful by an application. 

\subsection{IoT architecture}

The architecture of an Internet of Things solution can be implemented with various technologies and in very different infrastructures. However, a generic high level architecture is common to all IoT projects:
\begin{figure}[H]
	\includegraphics[width=\textwidth,height=200pt]{assets/Abstract_IoT_Architecture.png} 
	\caption{Generic Architecture}
	\label{fig:genericArchitecture}
\end{figure}

\textbf{Perception Layer:} The perception layer or device layer is the layer where physical objects will be able to capture data via sensors. These sensors are able to collect real world data. These data can be or not be processed upstream to add meta-data by the connected object itself and will be forwarded to the Network Layer.

\textbf{Network Layer:} The Network Layer or Transmission Layer. This layer transfers the informations from to Perception Layer to the Middleware Layer. This transfer can be accomplished by different communication technologies like Wifi, 3g, Bluetooth, etc.

\textbf{Middleware Layer:} The Middleware Layer is the common layer for all physical objects of an IoT architecture. The middleware is responsible to take automatic decisions based on informations coming for the devices and store the results in a database. 

\textbf{Application and Business Layer}: The Application Layer is where smart applications are running to produce complex processes. These applications will consume data from connected objects previously processed by the middleware to act effectively on a specific situation. These application can transmit actions to execute on a particular type of service. The Business Layer is important for the global management of the system. This one is rather a layer of global monitoring which produces graphs and statistics at the business level.

\subsection{Data Flow}

The previous architecture can be simplified to highlight the layer of architecture on which this state of the art will focus.
\newline
\begin{figure}[h]
	\includegraphics[width=\textwidth,height=180pt]{assets/Basic_IOT_Architecture.png} 
	\caption{Simple IoT Architecture}
	\label{fig:simpleArchitecture}
\end{figure}

This state of the art is focusing on the "Computation and Processing System" layer because at that stage, the data processing is the most critical and the data flow is the highest. Obviously, the Communication Layer must be robust enough to transmit the data efficiently but this topic will not be tackled in this article.

%----------------------------------------------------------------------------------------
%	Complex Event Processing
%----------------------------------------------------------------------------------------

\section{Complex Event Processing}

\subsection{Definition}

Complex Event Processing (CEP) is a set of methods and techniques for tracking
and analysing real-time streams of informations and detecting patterns or correlations
of unrelated data (complex events) that are of interest to a particular
business. \cite{1} The complex event processing is the engine of real-time applications that needs to have real-time informations from an environment to respond as fast as possible. A standard Request/Reply with synchronous processes cannot correlate different type of events and respond in a timely manner. Complex Event Processing mechanisms are often used in Event Driven architectures. This architecture fits with the Internet of Things needs. This kind of architecture is driven by events sent by connected objects. Then, the services at the application layer are consuming those events.

\subsection{Event Correlation}

The events coming directly from the Thing's sensors are call raw events. Those events are the trigger of one or multiple process in an IoT solution. The raw events are the events coming from the real world. It may represent a simple real-world event or a complex real-world event. Those raw events often need to be pre-processed before integrating a more sophisticated system. Without the pre-processing it would be difficult for a system to understand the information correctly and correlate it with other events. A strict semantic between different type of events have to be put in place for the whole IoT system. That's why a complete ontology should structure all the domain application. Generally, two types of events can occur in the system: Internal and External. The internal events are the events sent by the application layer. The external event are the events sent by the "physical" sensors.

\subsection{CEP Engine} \label{cep-engine}

The CEP engine is consuming the events sent by the physical objects on the Communication Layer. This engine can define a bunch of rules where each event received will be evaluated. A rule represents a complex condition that can be based on multiple events and on a time window. For example, if all connected cameras in a house are sending that there aren't any move in the house in a time window of 60 seconds, an event saying that nobody is in the house will be sent. Then, some specific actions can be taken by connected devices in the house. Basically, a Complex Event Processing Engine correlates multiple type of events based on the time. Then, if the pattern defined in the rule is matching with the ingested events, a complex event is sent. A complex event is an event that summarizes, represents, or denotes a set of other events\cite{glossary}. The complex events generated can themselves triggers another CEP rule or an application process.
\newline
\begin{figure}[h]
	\includegraphics[width=\textwidth,height=160pt]{assets/cep-pattern-decision-reaction.png} 
	\caption{CEP Pattern Decision Reaction}
	\label{fig:cep-pattern-decision-reaction}
\end{figure}

The rules are able to correlate different type of events only if their structure are known. If an event is unrecognisable by the pattern, this event can be ignored or a different kind of action can be put in place. It is possible to send a warning event that something unexpected by the system happened for example. 
\newline
\newline
The technologies implementing CEP concepts are querying Time Series Databases where each event received are stored. Thoses databases are optimised for queries based on a time window. In a lot of CEP framework like Apache Flink, those CEP pattern matching rules are describe seemly an SQL Query and uses Event Pattern Languages. 

\subsection{Event Pattern Languages}

An Event Pattern Language (EPL) is a language used by CEP engines in order to describe the relations between events that match a specific pattern. The syntax of EPL's are quite similar to SQL queries. The Example 1 is retrieving dates where the temperature was bigger than 30 degrees Celsius.
\newline
\newline
\underline{\textbf{Example 1:}}
\begin{verbatim}
	SELECT Thermometer.date
	FROM DataSource
	WHERE temperature > 30
\end{verbatim}
A plenty of primitive operators exists in Event Pattern Languages to describe the rule's behaviour. The following operators are coming from ThingML framework but are available in most of CEP frameworks:
\newline
\newline
\textbf{Selection:} Filters relevant events based on the values of their attributes.\cite{6} For example, we can select all Air Pressure events between 101300 Pa and 101400 Pa.
\newline
\textbf{Projection:} Extracts or transforms a subset of attributes of the events.\cite{6}
\newline
\textbf{Window:} Defines which portions of the input events to be considered for detecting pattern.\cite{6} For example, a rule can concern the last 30 seconds events.
\newline
\textbf{Conjunction:} Consider the occurrences of two or more events.\cite{6} This operator is basically a logical 'AND' operator.
\newline
\textbf{Disjunction:} Consider the occurrences of either one ore more events in a predefined set.\cite{6} This operator is basically a logical 'OR' operator.
\newline
\textbf{Sequence:} Introduces ordering relations among events of a pattern which is satisfied when all the events have been detected in the specified order.\cite{6}
\newline
\textbf{Repetition:} Considers a number of occurrences of a particular event.\cite{6}
\newline
\textbf{Aggregation:} Introduces constraints involving some aggregated attribute values.\cite{6} For example, the average temperature of all Weather events is an aggregation.
\newline
\textbf{Negation:} Prescribes the absence of certain events.\cite{6} This operator is basically a logical 'NOT' operator.

%--------------------------------------------------------------------------------------

\subsection{Event-Condition-Action Pattern}

As seen in section \ref{cep-engine}, the CEP Engine is composed of events to detect, a set of rules to execute and actions to perform. Basically, this CEP approach is called Event-Condition-Action and separate the operations in three stages : Event processing, Condition evaluation and Action execution. This pattern is often used in the most popular CEP Frameworks (e.g.Apache Flink, Esper, Google Dataflow and Apache Heron). The Event processing stage is itself divided into three parts : Event detection, Event subscription and Event processing. The aforementioned stage is responsible to detect events, subscribe and process events. The condition stage is the step where rules are defined by Event Pattern Languages. The Rule Engine is composed of a fact base and rule base. The fact base represents the current state of all facts defined in the system. A fact is a situation that can occur in the system. For example, if a detection event is sent by a sensor in a bedroom, the fact can be "Someone is in the Bob's bedroom". Rules consist of an ECA based pattern: on {<}event{>} if {<}condition{>} then {<}action{>}. Whenever an event occurs, the rule scanner checks all relevant rules to determine any consequent actions that need to be initiated. \cite{IoT Architecture based on services and Events}

\begin{figure}[h]
	\includegraphics[width=\textwidth,height=90pt]{assets/ECA_illustration.png}
	\caption{Event-Condition-Action}
	\label{fig:Event-Condition-Action}
\end{figure}

\subsection{Database and Data Stream Management Systems}

Real-time applications are consuming the data in a different way comparing to a traditional system. A traditional information system using a Database Management Systems (DBMS), the information stored in the database related to an specific entity is a "static" data persisted. The information stored in an aggregation of the reality. Only the current state of the information is relevant for the system. This type of Data management doesn't fit all real-time applications' needs. A real-time application needs to correlate each events coming into the system. An IoT solution is sending too much data into the system. It's not possible for a traditional database to store, query and respond in a timely manner. 
\newline
\newline
The Data Stream Management Systems (DSMS) are designed to handle potentially infinite and fast changing event streams. Obviously, it is not possible to query the all history of events that came from the beginning of the solution and respond in milliseconds. Different approaches exist to limit the amount of data processed. Roughly, compression techniques exists to summarize a set of data already queried. Another technique consists of setting a time window to pick a portion of data in the time. 

%--------------------------------------------------------------------------------------

\section{Computing Levels}

The main preoccupations of a real-time solution in IoT is to have the lowest latency between all devices. To process all data coming from sensors, CEP engines can help reducing the processing time. The CEP engines can be placed at different level of the IoT architecture. The place where Complex Event Processing is used depends of the business needs. 

%----------------------------------------------------------------------------------------

\subsection{Cloud Computing}

The Cloud Computing places the computing complexity at the cloud level. All the data coming from the sensors have to transit by the connected object, sometimes by a middleware and then it can be consumed by a CEP Engine in the cloud. The Cloud Computing is common for near real-time applications where a little bit of latency is not critical.
\newline
\begin{figure}[h]
	\includegraphics[width=\textwidth,height=160pt]{assets/Cloud_Computing.png}
	\caption{Cloud Computing}
	\label{fig:Cloud-Computing}
\end{figure}

This solution is optimal for the near real-time cloud monitoring because all events coming from the devices are sent to the cloud. Then a precise metrics history can be retrieved. Obviously all data persisted have a cost. This type of solution is extremely demanding in storage space if all the history is persisted.
\newline
\newline
Of course the Cloud Computing can be coupled with other levels of computing and it's often the case. The Cloud Computing can be placed on the top of a multi site IoT solutions where millions of data are coming from thousands of connected objects in the world. Then this solution can reflect a High Level overview of a global IoT system and available all over the world.

%----------------------------------------------------------------------------------------

\subsection{Fog Computing}

The Fog Computing places the computing intelligence at the local network level. Typically the complexity is put between the Cloud and the IoT sensors. The devices are sending their data to a Middleware and the CEP engine is processing the data locally and send the processed events to a service running in the Cloud or on a local server. This method offers the CEP performances on a closer level where the data are created. Then the applications where latency is crucial, the Fog Computing can fit with their business needs. For example, the auto mobile or aerospace sector are more and more connected and the reactivity of their system needs to be as fast as possible. Compared to a device-to-cloud architecture, placing processing closer to the devices can reduce the latency since the physical distance is shorter and potential response time in a data center can be removed. Compared to a deviceonly architecture, latency can be reduced since computationintensive tasks that take a long time on resource-constrained sensor devices can be moved to more capable fog computing nodes. The motivation can also be to keep the latency predictable.\cite{7248934}

\begin{figure}[H]
	\includegraphics[width=\textwidth,height=160pt]{assets/Fog_Computing.jpg}
	\caption{Fog Computing}
	\label{fig:Fog-Computing}
\end{figure}

It can happen that the edge devices are sending too much data at very high rate. Therefore the processing engine at fog level is not treating the data fast enough because the processing of a huge amount of data is taking too much time. The Complex Event Processing can be put at the Edge devices level. The terms Fog and Edge computing have different meanings depending on the article. In some article, edge computing refers to the enabling technologies allowing computation to be performed at the edge of the network,on downstream data on behalf of cloud services and upstream data on behalf of IoT services.\cite{Edge Computing - Vision and Challenges} The limit between Fog and Edge computing is not clear. In this state-of-the-art we consider the Fog to be a higher layer on the top of physical devices like a server on a private network. 

%----------------------------------------------------------------------------------------

\subsection{Edge Computing}

The Edge Computing places the computing complexity at the Physical Layer. It can be an IoT gateway where data is pre-processed before being pushed to the Cloud or whatever. For example, in e-health some sensors can be put in a human body and the informations coming from the sensors are sent to a smartphone. The smartphone is processing those information before sending them. This method reduces the network traffic to the Fog Nodes and/or the Cloud because less informations will be transferred. Therefore it reduces the risk of data congestion and the CEP engines are not flooded. Edge Computing is generally used by industries in Cyber Physical Systems\footnote{Cyber-Physical Systems (CPS) are integrations of computation and physical processes. Embedded computers and networks monitor and control the physical processes, usually with feedback loops where physical processes affect computations and vice versa \cite{5}}.

%----------------------------------------------------------------------------------------

\section{Semantic Publish-Subscribe Architecture}

The article "A Semantic Publish-Subscribe Architecture" \cite{A Semantic Publish-Subscribe Architecture} suggests an interesting asynchronous architecture based on the Publish-Subscribe design pattern. The publish-subscribe pattern in software architecture is a messaging pattern where the sender of the message doesn't know the receiver. On the other side, the receiver doesn't know the sender as well. The publisher is sending a message on a message queue where subscriber(s) are listening to. In Internet of Things solutions, the producers and consumers can be the connected objects themselves but it can also be an application layer in the Cloud for example. The connected objects are publishing events on event topics and the application layer processes those events.

\begin{figure}[H]
	\includegraphics[width=\textwidth,height=200pt]{assets/SPS_Architecture.png}
	\caption{Semantic Publish Subscribe Architecture\cite{article_SPS}}
	\label{fig:Semantic-Publish-Subscribe-Architecture}
\end{figure}

The SPS architecture prone the modularity, extensibility and cost-effective vision. It splits the physical world from its digital representation. The primary characteristic consists of splitting clients into 3 categories: consumers, producers and aggregators. The business logic is driven by the aggregators. The producers and the consumers are the bridge between the physical world and the virtual representation of the systems. This principle keeps the business logic at the aggregator level in order to keep the clients and producers as simple as possible. It gives to the producers the unique responsibility to send data to an upper layer without executing any business logic. Hence, this system is easier to extend because only the aggregator layer is impacted if a business feature is added. Then, the consumers and producers can be shared by different applications.
\newline
\newline
The role of the producers is to collect the data from the sensors. The producer can optionally make a local processing where it encapsulate the data to a semantic format. After that, the producer send the information to the SUB Engine that will store the data in a Triplestore.
Contrarily, the consumers are listening to the concrete events coming in the SUB Engine that can be a result of a processing done by an aggregator. After receiving an notification, the consumers extract the raw data and send it to a devices through a legacy interface.
\begin{figure}[H]
	\includegraphics[width=\textwidth,height=190pt]{assets/simple_SPS_example.png}
	\caption{Sequence diagram of Smart Lightning\cite{article_SPS}}
	\label{fig:Sequence-diagram-of-Smart-Lightning}
\end{figure}
The aggregators are listening to the events sent by the producer through the SUB Engine. Each aggregator subscribes to each event type they need for their business process. The fig.\ref{fig:Sequence-diagram-of-Smart-Lightning} exposes a simple use case of Smart Lightning where each type of clients described previously is used. The presence sensor acts as a producer and store the presence state in the RDF Store. The Lamp actuator acts as a consumer and subscribe to the Lamp events. The Smart Lightning acts as an aggregator to handle incoming events and triggers a business process based on those events.
\newline
\newline
\textbf{Scenario:}
\newline
1. The Lamp Actuator is subscribing to the Lamp events and the Smart Lightning aggregator is subscribing to the Presence events.
2. The Presence sensor is Sending an Event to the SUB Engine that a presence is detected. 
3. The presence event is captured by the Smart Lighting aggregator that will send an event to switch on the lamp. 
4. The "Switch ON the lamp" event is captured by the Lamp actuator that communicate the information to the connected lamp. 
5. The presence sensors is sending that no presence is detected. 
6. The Smart Lightning schedules to send an event to switch off the light after x seconds if no presence is detected during that time laps.
7. A presence is detected, then the Smart Lightning cancels his event scheduling.
8. The presence sensors is sending that no presence is detected. 
9. The Smart Lightning schedules to send an event to switch off the light after x seconds if no presence is detected during that time laps.
10. The Smart Lightning Aggregator sends the "Switch off lamp" event.
11. The Lamp actuator is switching off the light.

%----------------------------------------------------------------------------------------

\section{Micro-service architecture}


%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

\section{Domain of applications}


	\subsection{Fault Tolerance}


%----------------------------------------------------------------------------------------

\section{Problematic}



\textcolor{red}{Parler de l'idée envoyée par mail mais de manière structurée + comment quantifier + questions et sous questions}

%----------------------------------------------------------------------------------------

\section{Research Methodology}

%----------------------------------------------------------------------------------------

\section{Conclusions}

%----------------------------------------------------------------------------------------
%----------------------------------------THE END-----------------------------------------
%----------------------------------------------------------------------------------------

\newpage
\listoffigures
\nocite{*}
\printbibliography

\end{document}
